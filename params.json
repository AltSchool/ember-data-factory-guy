{
  "name": "Ember-data-factory-guy",
  "tagline": "Factories for testing with Ember Data",
  "body": "# Ember Data Factory Guy\r\n\r\n[![Build Status](https://secure.travis-ci.org/danielspaniel/ember-data-factory-guy.png?branch=master)](http://travis-ci.org/danielspaniel/ember-data-factory-guy) [![Ember Observer Score](http://emberobserver.com/badges/ember-data-factory-guy.svg)](http://emberobserver.com/addons/ember-data-factory-guy) [![npm version](https://badge.fury.io/js/ember-data-factory-guy.svg)](http://badge.fury.io/js/ember-data-factory-guy)\r\n         \r\nFeel the thrill and enjoyment of testing when using Factories instead of Fixtures.  \r\nFactories simplify the process of testing, making you more efficient and your tests more readable.  \r\n\r\n- Support for **[ember-data-model-fragment](https://github.com/lytics/ember-data-model-fragments)** usage is baked in since v2.5.0\r\n- Support for **[ember-django-adapter](https://github.com/dustinfarris/ember-django-adapter)** usage is fried in since v2.6.1 \r\n- Support for adding [meta data](https://github.com/danielspaniel/ember-data-factory-guy#using-add-method) to payloads for use with **ember-infinity** ie. => pagination  \r\n- Support for adding headers to payloads\r\n- Since you using ember data, you don't need to create any ORM like things. \r\n  - You don't need to add any files to re create all the relationships in your models and serializers\r\n  - You don't have to setup anything.\r\n  - Everything just works.\r\n                                  \r\nQuestions: Slack => [factory-guy](https://embercommunity.slack.com/messages/e-factory-guy/)\r\n\r\nContents:\r\n  - [Installation](https://github.com/danielspaniel/ember-data-factory-guy#installation)\r\n  - [How This Works](https://github.com/danielspaniel/ember-data-factory-guy#how-this-works)\r\n  - [Setup](https://github.com/danielspaniel/ember-data-factory-guy#setup)\r\n  - [Defining Factories](https://github.com/danielspaniel/ember-data-factory-guy#defining-factories)\r\n  - [Using Factories](https://github.com/danielspaniel/ember-data-factory-guy#using-factories)\r\n  - [Sequences](https://github.com/danielspaniel/ember-data-factory-guy#sequences)\r\n  - [Inline Function](https://github.com/danielspaniel/ember-data-factory-guy#inline-functions)\r\n  - [Traits](https://github.com/danielspaniel/ember-data-factory-guy#traits)\r\n  - [Associations](https://github.com/danielspaniel/ember-data-factory-guy#associations)\r\n  - [Extending Other Definitions](https://github.com/danielspaniel/ember-data-factory-guy#extending-other-definitions)\r\n  - [Callbacks](https://github.com/danielspaniel/ember-data-factory-guy#callbacks)\r\n  - [Ember Data Model Fragments](https://github.com/danielspaniel/ember-data-factory-guy#ember-data-model-fragments)\r\n  - [Creating Factories in Addons](https://github.com/danielspaniel/ember-data-factory-guy#creating-factories-in-addons)\r\n  - [Ember Django Adapter](https://github.com/danielspaniel/ember-data-factory-guy#ember-django-adapter)\r\n  - [Custom API formats](https://github.com/danielspaniel/ember-data-factory-guy#custom-api-formats)\r\n  - [Testing - creating scenarios](https://github.com/danielspaniel/ember-data-factory-guy#testing---creating-scenarios)\r\n  - [Testing models, controllers, components](https://github.com/danielspaniel/ember-data-factory-guy#testing-models-controllers-components)\r\n  - [Acceptance Tests](https://github.com/danielspaniel/ember-data-factory-guy#acceptance-tests)\r\n                            \r\nChangeLog: ( Notes about what has changed in each version )\r\n  - [Release Notes](https://github.com/danielspaniel/ember-data-factory-guy/releases)\r\n\r\n### Installation\r\n\r\n - ```ember install ember-data-factory-guy@2.6.5``` ( ember-data-1.13.5+ )\r\n - ```ember install ember-data-factory-guy@1.13.2``` ( ember-data-1.13.0 + )\r\n - ```ember install ember-data-factory-guy@1.1.2``` ( ember-data-1.0.0-beta.19.1 )\r\n - ```ember install ember-data-factory-guy@1.0.10``` ( ember-data-1.0.0-beta.16.1 )\r\n\r\n### Upgrade\r\n -  remove ember-data-factory-guy from package.json\r\n - ```npm prune```\r\n - ```ember install ember-data-factory-guy  ( for latest release )``` \r\n \r\n### How this works\r\n\r\n  - You create factories for you models.\r\n    - put them in tests/factories directory\r\n  - Then you use them to create models in your tests.\r\n    - You can make records that persist in the store\r\n    - Or you can build a json payload used for mocking an ajax call's payload\r\n\r\n[![Thumbnail of Introduction to ember-data-factory-guy](https://i.vimeocdn.com/video/545504017.png?mw=1920&mh=1080)](https://vimeo.com/album/3607049/video/146964694)\r\n\r\n### Setup\r\n\r\nIn the following examples, assume the models look like this:\r\n\r\n```javascript\r\n  // standard models\r\n  User = DS.Model.extend({\r\n    name:     DS.attr('string'),\r\n    style:    DS.attr('string'),\r\n    projects: DS.hasMany('project'),\r\n    hats: DS.hasMany('hat', {polymorphic: true})\r\n  });\r\n\r\n  Project = DS.Model.extend({\r\n    title:  DS.attr('string'),\r\n    user:   DS.belongsTo('user')\r\n  });\r\n\r\n  // polymorphic models\r\n  Hat = DS.Model.extend({\r\n    type: DS.attr('string'),\r\n    user: DS.belongsTo('user')\r\n  });\r\n\r\n  BigHat = Hat.extend();\r\n  SmallHat = Hat.extend();\r\n```\r\n\r\n\r\n### Defining Factories\r\n - A factory has a name and a set of attributes.\r\n - The name should match the model type name. So, for 'User' model, the name would be 'user'\r\n - Create factory files in the tests/factories directory.\r\n - Can use generator to create the outline of a factory file:\r\n  ```ember g factory user``` This will create a file named user.js in the tests/factories directory.\r\n\r\n\r\n##### Standard models\r\n\r\n- [Sample full blown factory: (user.js)](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/dummy/app/tests/factories/user.js)\r\n\r\n```javascript\r\n\r\n  // file tests/factories/user.js\r\n  import FactoryGuy from 'ember-data-factory-guy';\r\n\r\n  FactoryGuy.define('user', {\r\n    // Put default 'user' attributes in the default section\r\n    default: {\r\n      style: 'normal',\r\n      name: 'Dude'\r\n    },\r\n    // Create a named 'user' with custom attributes\r\n    admin: {\r\n      style: 'super',\r\n      name: 'Admin'\r\n    }\r\n  });\r\n\r\n```\r\n\r\n\r\n##### Polymorphic models\r\n\r\n - Define each polymorphic model in it's own typed definition\r\n - May want to extend parent factory here\r\n   - See [Extending Other Definitions](https://github.com/danielspaniel/ember-data-factory-guy#extending-other-definitions)\r\n\r\n```javascript\r\n\r\n  // file tests/factories/small-hat.js\r\n  import FactoryGuy from 'ember-data-factory-guy';\r\n\r\n  FactoryGuy.define('small-hat', {\r\n    default: {\r\n      type: 'SmallHat'\r\n    }\r\n  })\r\n\r\n  // file tests/factories/big-hat.js\r\n  import FactoryGuy from 'ember-data-factory-guy';\r\n\r\n  FactoryGuy.define('big-hat', {\r\n    default: {\r\n      type: 'BigHat'\r\n    }\r\n  })\r\n\r\n```\r\n\r\nIn other words, don't do this:\r\n\r\n```javascript\r\n  // file tests/factories/hat.js\r\n  import FactoryGuy from 'ember-data-factory-guy';\r\n\r\n  FactoryGuy.define('hat', {\r\n    default: {},\r\n    small-hat: {\r\n      type: 'SmallHat'\r\n    },\r\n    big-hat: {\r\n      type: 'BigHat'\r\n    }\r\n  })\r\n\r\n```\r\n\r\n\r\n### Using Factories\r\n\r\n - FactoryGuy.make\r\n   - Loads model instance into the store\r\n - FactoryGuy.makeList\r\n   - Loads zero to many model instances into the store\r\n - FactoryGuy.build\r\n   - Builds json in accordance with the adapters specifications\r\n     - [RESTAdapter](http://emberjs.com/api/data/classes/DS.RESTAdapter.html)  (*assume this adapter being used in most of the following examples*)\r\n     - [ActiveModelAdapter](https://github.com/ember-data/active-model-adapter#json-structure)\r\n     - [JSONAPIAdapter](http://jsonapi.org/format/)\r\n     - [DrfAdapter (Ember Django Adapter)](https://github.com/dustinfarris/ember-django-adapter)\r\n - FactoryGuy.buildList\r\n   - Builds json with list of zero or more items in accordance with the adapters specifications\r\n - Can override default attributes by passing in an object of options\r\n - Can add attributes or relationships with [traits](https://github.com/danielspaniel/ember-data-factory-guy#traits)\r\n - Can compose relationships \r\n    - By passing in other objects you've made with build/buildList or make/makeList \r\n\r\n##### make/makeList\r\n  - all instances loaded into the ember data store\r\n\r\nUsage:\r\n\r\n##### make  \r\n```javascript\r\n\r\n  import { make } from 'ember-data-factory-guy';\r\n  \r\n  // make basic user with the default attributes in user factory\r\n  let user = make('user');\r\n  user.toJSON({includeId: true}) // => {id: 1, name: 'User1', style: 'normal'}\r\n  \r\n  // make user with default attributes plus those defined as 'admin' in user factory\r\n  let user = make('admin');\r\n  user.toJSON({includeId: true}) // => {id: 2, name: 'Admin', style: 'super'}\r\n\r\n  // make user with default attributes plus these extra attributes\r\n  let user = make('user', {name: 'Fred'});\r\n  user.toJSON({includeId: true}) // => {id: 3, name: 'Fred', style: 'normal'}\r\n\r\n  // make admin defined user with these extra attributes\r\n  let user = make('admin', {name: 'Fred'});\r\n  user.toJSON({includeId: true}) // => {id: 4, name: 'Fred', style: 'super'}\r\n  \r\n  // make default user with traits and with extra attributes\r\n  let user = make('user', 'silly', {name: 'Fred'});\r\n  user.toJSON({includeId: true}) // => {id: 5, name: 'Fred', style: 'silly'}\r\n\r\n  // make user with hats relationship ( hasMany ) composed of a few pre 'made' hats\r\n  let hat1 = make('big-hat');\r\n  let hat2 = make('big-hat');\r\n  let user = make('user', {hats: [hat1, hat2]});\r\n  user.toJSON({includeId: true})  \r\n  // => {id: 6, name: 'User2', style: 'normal', hats: [{id:1, type:\"big_hat\"},{id:1, type:\"big_hat\"}]}\r\n  // note that hats are polymorphic. if they weren't, the hats array would be a list of ids: [1,2]\r\n\r\n  // make user with company relationship ( belongsTo ) composed of a pre 'made' company\r\n  let company = make('company');\r\n  let user = make('user', {company: company});\r\n  user.toJSON({includeId: true})  // => {id: 7, name: 'User3', style: 'normal', company: 1} \r\n\r\n```\r\n\r\n##### makeList\r\n  - check out [(user factory):](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/dummy/app/tests/factories/user.js) to see 'bob' user and 'with_car' trait  \r\n\r\nUsage:\r\n\r\n```javascript\r\n\r\n  import { make, makeList } from 'ember-data-factory-guy';\r\n  \r\n  // Let's say bob is a named type in the user factory\r\n  makeList('bob') // makes 0 bob's\r\n\r\n  makeList('bob', 2) // makes 2 bob's\r\n\r\n  makeList('bob', 2, 'with_car' , {name: \"Dude\"})\r\n  // makes 2 bob's that have 'with_car' trait and name of \"Dude\"\r\n  // In other words, applies the traits and options to every bob made  \r\n\r\n  makeList('bob', 'with_car', ['with_car',{name: \"Dude\"}])\r\n  // 2 User models with bob attributes, where the first also has 'with_car' trait\r\n  // the last has 'with_car' trait and name of \"Dude\", so you get 2 different bob's\r\n  \r\n\r\n```\r\n##### build\r\n  - for building json that you can pass as json payload in [acceptance tests](https://github.com/danielspaniel/ember-data-factory-guy#acceptance-tests)\r\n  - takes same arguments as make \r\n  - can compose relationships with other build/buildList payloads\r\n  - to inspect the json use the get() method\r\n  - use [add](https://github.com/danielspaniel/ember-data-factory-guy#using-add-method) method \r\n    - to include extra sideloaded data to the payload\r\n    - to include meta data\r\n  \r\nUsage: \r\n\r\n```javascript\r\n  \r\n  import { build, buildList } from 'ember-data-factory-guy';  \r\n  \r\n  // build basic user with the default attributes in user factory\r\n  let json = build('user');\r\n  json.get() // => {id: 1, name: 'User1', style: 'normal'}\r\n\r\n  // build user with default attributes plus those defined as 'admin' in user factory  \r\n  let json = build('admin');\r\n  json.get() // => {id: 2, name: 'Admin', style: 'super'}\r\n  \r\n  // build user with default attributes plus these extra attributes\r\n  let json = build('user', {name: 'Fred'});\r\n  json.get() // => {id: 3, name: 'Fred', style: 'normal'}\r\n\r\n  // build admin defined user with extra attributes\r\n  let json = build('admin', {name: 'Fred'});\r\n  json.get() // => {id: 4, name: 'Fred', style: 'super'}\r\n\r\n  // build default user with traits and with extra attributes\r\n  let json = build('user', 'silly', {name: 'Fred'});\r\n  json.get() // => {id: 5, name: 'Fred', style: 'silly'}\r\n\r\n  // build user with hats relationship ( hasMany ) composed of a few pre 'built' hats \r\n  let hat1 = build('big-hat');\r\n  let hat2 = build('big-hat');\r\n  let json = build('user', {hats: [hat1, hat2]});\r\n  // note that hats are polymorphic. if they weren't, the hats array would be a list of ids: [1,2]\r\n  json.get() // => {id: 6, name: 'User2', style: 'normal', hats: [{id:1, type:\"big_hat\"},{id:1, type:\"big_hat\"}]}\r\n  \r\n  // build user with company relationship ( belongsTo ) composed of a pre 'built' company\r\n  let company = build('company');\r\n  let json = build('user', {company: company});\r\n  json.get() // => {id: 7, name: 'User3', style: 'normal', company: 1} \r\n\r\n  // build and compose relationships to unlimited degree\r\n  let company1 = build('company', {name: 'A Corp'});\r\n  let company2 = build('company', {name: 'B Corp'});\r\n  let owners = buildList('user', { company:company1 }, { company:company2 });\r\n  let buildJson = build('property', { owners });\r\n\r\n```\r\n- Example of what json payload from build looks like\r\n - Although the RESTAdapter is being used, this works the same with ActiveModel or JSONAPI adapters\r\n\r\n```javascript\r\n\r\n  let json = build('user', 'with_company', 'with_hats');\r\n  json // =>\r\n    {\r\n      user: {\r\n        id: 1,\r\n        name: 'User1',\r\n        company: 1,\r\n        hats: [\r\n          {type: 'big_hat', id:1},\r\n          {type: 'big_hat', id:2}\r\n        ]\r\n      },\r\n      companies: [\r\n        {id: 1, name: 'Silly corp'}\r\n      ],\r\n      'big-hats': [\r\n        {id: 1, type: \"BigHat\" },\r\n        {id: 2, type: \"BigHat\" }\r\n      ]\r\n    }\r\n\r\n```\r\n\r\n##### buildList\r\n  - for building json that you can pass as json payload in [acceptance tests](https://github.com/danielspaniel/ember-data-factory-guy#acceptance-tests)\r\n  - takes the same arguments as makeList\r\n  - can compose relationships with other build/buildList payloads\r\n  - to inspect the json use the get() method\r\n    - can use get(index) to get to items in the list\r\n  - use [add](https://github.com/danielspaniel/ember-data-factory-guy#using-add-method) method \r\n    - to add extra sideloaded data to the payload => `.add({json})`\r\n    - to add meta data => `.add({meta})`\r\n\r\n           \r\nUsage: \r\n\r\n```js\r\n  import { build, buildList } from 'ember-data-factory-guy';\r\n  \r\n  let owners = buildList('bob', 2);  // builds 2 Bob's\r\n  \r\n  let owners = buildList('bob', 2, {name: 'Rob'); // builds 2 Bob's with name of 'Rob'\r\n  \r\n  // builds 2 users, one with name 'Bob' , the next with name 'Rob'  \r\n  let owners = buildList('user', { name:'Bob' }, { name:'Rob' });\r\n```\r\n\r\n##### Using add() method\r\n - when you need to add more json to payload \r\n  - will be sideloaded \r\n    - only JSONAPI, and REST based serializers can do sideloading\r\n    - so DRFSerializer and JSONSerializer users can not user this feature\r\n\r\nUsage:\r\n\r\n```js\r\n  let batMan = build('bat_man');\r\n  let userPayload = build('user').add({json:batMan});\r\n \r\n  userPayload = {\r\n    user: {\r\n      id: 1,\r\n      name: 'User1',\r\n      style: \"normal\"\r\n    },\r\n    'super-heros': [\r\n      {\r\n        id: 1,\r\n        name: \"BatMan\",\r\n        type: \"SuperHero\"\r\n      }\r\n    ]\r\n  };\r\n```\r\n- when you want to add meta data to payload \r\n  - only JSONAPI, and REST based and serializers and DRFSerializer can handle meta data\r\n  - so JSONSerializer users can not user this feature ( though this might be a bug on my part )\r\n\r\nUsage:\r\n\r\n```js\r\n  let json1 = buildList('profile', 2).add({ meta: { previous: '/profiles?page=1', next: '/profiles?page=3' } });\r\n  let json2 = buildList('profile', 2).add({ meta: { previous: '/profiles?page=2', next: '/profiles?page=4' } });\r\n\r\n  mockQuery('profile', {page: 2}).returns({ json: json1 });\r\n  mockQuery('profile', {page: 3}).returns({ json: json2 });\r\n\r\n store.query('profile', {page: 2}).then((records)=> // first 2 from json1\r\n store.query('profile', {page: 3}).then((records)=> // second 2 from json2\r\n\r\n```\r\n\r\n##### Using get() method \r\n  - for inspecting contents of json payload\r\n    - get() returns all attributes of top level model \r\n    - get(attribute) gives you attribute in top level model\r\n    - get(index) gives you the info for hasMany relationship at that index\r\n    - get(relationships) gives you just id or type ( if polymorphic )\r\n      - better to compose the build relationships by hand if you need more info\r\n  - check out [user factory:](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/dummy/app/tests/factories/user.js) to see 'boblike' and 'adminlike' user traits\r\n\r\n```js \r\n  let json = build('user');\r\n  json.get() //=> {id: 1, name: 'User1', style: 'normal'}\r\n  json.get('id') // => 1\r\n  \r\n  let json = buildList('user', 2);\r\n  json.get(0) //=> {id: 1, name: 'User1', style: 'normal'}\r\n  json.get(1) //=> {id: 2, name: 'User2', style: 'normal'}\r\n  \r\n  let json = buildList('user', 'boblike', 'adminlike');\r\n  json.get(0) //=> {id: 1, name: 'Bob', style: 'boblike'}\r\n  json.get(1) //=> {id: 2, name: 'Admin', style: 'super'}\r\n```\r\n\r\n* building relationships inline\r\n  \r\n```javascript\r\n\r\n  let json = build('user', 'with_company', 'with_hats');\r\n  json.get() //=> {id: 1, name: 'User1', style: 'normal'}\r\n  \r\n  // to get hats (hasMany relationship) info\r\n  json.get('hats') //=> [{id: 1, type: \"big_hat\"},{id: 1, type: \"big_hat\"}]\r\n  \r\n  // to get company ( belongsTo relationship ) info\r\n  json.get('company') //=> {id: 1, type: \"company\"}\r\n\r\n```\r\n\r\n* by composing the relationships you can get the full attributes of those associations\r\n\r\n```javascript\r\n\r\n  let company = build('company');\r\n  let hats = buildList('big-hats');\r\n\r\n  let user = build('user', {company: company, hats: hats});\r\n  user.get() //=> {id: 1, name: 'User1', style: 'normal'}\r\n\r\n  // to get hats info from hats json \r\n  hats.get(0) //=> {id: 1, type: \"BigHat\", plus .. any other attributes}\r\n  hats.get(1) //=> {id: 2, type: \"BigHat\", plus .. any other attributes}\r\n\r\n  // to get company info\r\n  company.get() //=> {id: 1, type: \"Company\", name: \"Silly corp\"}\r\n\r\n```\r\n\r\n### Sequences\r\n\r\n- For generating unique attribute values.\r\n- Can be defined:\r\n    - In the model definition's sequences hash\r\n    - Inline on the attribute\r\n- Values are generated by calling FactoryGuy.generate\r\n\r\n##### Declaring sequences in sequences hash\r\n\r\n```javascript\r\n\r\n  FactoryGuy.define('user', {\r\n    sequences: {\r\n      userName: (num)=> `User${num}`\r\n    },\r\n\r\n    default: {\r\n      // use the 'userName' sequence for this attribute\r\n      name: FactoryGuy.generate('userName')\r\n    }\r\n  });\r\n\r\n  let json = FactoryGuy.build('user');\r\n  json.get('name') // => 'User1'\r\n\r\n  let user = FactoryGuy.make('user');\r\n  user.get('name') // => 'User2'\r\n\r\n```\r\n\r\n##### Declaring an inline sequence on attribute\r\n\r\n```javascript\r\n\r\n  FactoryGuy.define('project', {\r\n    special_project: {\r\n      title: FactoryGuy.generate((num)=> `Project #${num}`)\r\n    },\r\n  });\r\n\r\n  let json = FactoryGuy.build('special_project');\r\n  json.get('title') // => 'Project #1'\r\n\r\n  let project = FactoryGuy.make('special_project');\r\n  project.get('title') // => 'Project #2'\r\n\r\n```\r\n\r\n\r\n### Inline Functions\r\n\r\n- Declare a function for an attribute\r\n  - Can reference all other attributes, even id\r\n\r\n```javascript\r\n\r\n  FactoryGuy.define('user', {\r\n    sequences: {\r\n      userName: (num)=> `User${num}`\r\n    },\r\n    default: { \r\n      name: FactoryGuy.generate('userName') \r\n    },\r\n    traits: {\r\n      boringStyle: {\r\n        style: (f)=> `${f.id} boring `\r\n      }\r\n      funnyUser: {\r\n        style: (f)=> `funny ${f.name}`\r\n      }\r\n    }\r\n  });\r\n\r\n  let json = FactoryGuy.build('user', 'funny');\r\n  json.get('name') // => 'User1'\r\n  json.get('style') // => 'funny User1'\r\n\r\n  let user = FactoryGuy.make('user', 'boring');\r\n  user.get('id') // => 2\r\n  user.get('style') // => '2 boring'\r\n\r\n```\r\n\r\n*Note the style attribute was built from a function which depends on the name\r\n and the name is a generated attribute from a sequence function*\r\n\r\n\r\n### Traits\r\n- Used with build, buildList, make, or makeList\r\n- For grouping attributes together\r\n- Can use one or more traits in a row\r\n - The last trait included overrides any values in traits before it\r\n\r\n```javascript\r\n\r\n  FactoryGuy.define('user', {\r\n    traits: {\r\n      big: { name: 'Big Guy' }\r\n      friendly: { style: 'Friendly' }\r\n    }\r\n  });\r\n\r\n  let json = FactoryGuy.build('user', 'big', 'friendly');\r\n  json.get('name') // => 'Big Guy'\r\n  json.get('style') // => 'Friendly'\r\n\r\n  let user = FactoryGuy.make('user', 'big', 'friendly');\r\n  user.get('name') // => 'Big Guy'\r\n  user.get('style') // => 'Friendly'\r\n\r\n```\r\n\r\nYou can still pass in a hash of options when using traits. This hash of\r\nattributes will override any trait attributes or default attributes\r\n\r\n```javascript\r\n\r\n  let user = FactoryGuy.make('user', 'big', 'friendly', {name: 'Dave'});\r\n  user.get('name') // => 'Dave'\r\n  user.get('style') // => 'Friendly'\r\n\r\n```\r\n\r\n\r\n### Associations\r\n\r\n- Can setup belongsTo or hasMany associations in factory definitions\r\n    - As inline attribute definition\r\n    - With traits\r\n- Can setup belongsTo or hasMany associations manually \r\n  - With [build](https://github.com/danielspaniel/ember-data-factory-guy#build) / [buildList](https://github.com/danielspaniel/ember-data-factory-guy#buildlist) and [make](https://github.com/danielspaniel/ember-data-factory-guy#make) / [makeList](https://github.com/danielspaniel/ember-data-factory-guy#makelist) \r\n    - Can compose relationships to any level \r\n\r\n##### Setup belongsTo associations in Factory Definition\r\n\r\n```javascript\r\n  // Recall ( from above setup ) that there is a user belongsTo on the Project model\r\n  // Also, assume 'user' factory is same as from 'user' factory definition above in\r\n  // 'Defining Factories' section\r\n  FactoryGuy.define('project', {\r\n\r\n    project_with_user: {\r\n      // create user model with default attributes\r\n      user: {}\r\n    },\r\n    project_with_bob: {\r\n      // create user model with custom attributes\r\n      user: {name: 'Bob'}\r\n    },\r\n    project_with_admin: {\r\n      // create a named user model with the FactoryGuy.belongsTo helper method\r\n      user: FactoryGuy.belongsTo('admin')\r\n    }\r\n  });\r\n\r\n  let project = FactoryGuy.make('project_with_admin');\r\n  project.get('user.name') // => 'Admin'\r\n  project.get('user.style') // => 'super'\r\n\r\n```\r\n\r\n*You could also accomplish the above with traits:*\r\n\r\n```javascript\r\n\r\n  FactoryGuy.define('project', {\r\n    traits: {\r\n      with_user: { user: {} },\r\n      with_admin: { user: FactoryGuy.belongsTo('admin') }\r\n    }\r\n  });\r\n\r\n  let user = FactoryGuy.make('project', 'with_user');\r\n  project.get('user').toJSON({includeId: true}) // => {id:1, name: 'Dude', style: 'normal'}\r\n\r\n```\r\n\r\n\r\n##### Setup belongsTo associations manually\r\n  - See [build](https://github.com/danielspaniel/ember-data-factory-guy#build) / [buildList](https://github.com/danielspaniel/ember-data-factory-guy#buildlist) and [make](https://github.com/danielspaniel/ember-data-factory-guy#make) / [makeList](https://github.com/danielspaniel/ember-data-factory-guy#makelist) for more ideas \r\n\r\n```javascript\r\n  let user = FactoryGuy.make('user');\r\n  let project = FactoryGuy.make('project', {user: user});\r\n\r\n  project.get('user').toJSON({includeId: true}) // => {id:1, name: 'Dude', style: 'normal'}\r\n```\r\n\r\n*Note that though you are setting the 'user' belongsTo association on a project,\r\nthe reverse user hasMany 'projects' association is being setup for you on the user\r\n( for both manual and factory defined belongsTo associations ) as well*\r\n\r\n```javascript\r\n  user.get('projects.length') // => 1\r\n```\r\n\r\n\r\n\r\n##### Setup hasMany associations in Factory Definition\r\n\r\n``` javascript\r\n  FactoryGuy.define('user', {\r\n    user_with_projects: { projects: FactoryGuy.hasMany('project', 2) }\r\n  });\r\n\r\n  let user = FactoryGuy.make('user_with_projects');\r\n  user.get('projects.length') // => 2\r\n\r\n```\r\n\r\n*You could also accomplish the above with traits:*\r\n\r\n```javascript\r\n\r\n  FactoryGuy.define('project', {\r\n    traits: {\r\n      with_projects: {\r\n        projects: FactoryGuy.hasMany('project', 2)\r\n      }\r\n    }\r\n  });\r\n\r\n  let user = FactoryGuy.make('user', 'with_projects');\r\n  user.get('projects.length') // => 2\r\n\r\n```\r\n\r\n##### Setup hasMany associations manually\r\n  - See [build](https://github.com/danielspaniel/ember-data-factory-guy#build) / [buildList](https://github.com/danielspaniel/ember-data-factory-guy#buildlist) and [make](https://github.com/danielspaniel/ember-data-factory-guy#make) / [makeList](https://github.com/danielspaniel/ember-data-factory-guy#makelist) for more ideas\r\n  \r\n```javascript\r\n  let project1 = FactoryGuy.make('project');\r\n  let project2 = FactoryGuy.make('project');\r\n  let user = FactoryGuy.make('user', {projects: [project1,project2]});\r\n  user.get('projects.length') // => 2\r\n\r\n  // or\r\n  let projects = FactoryGuy.makeList('project', 2);\r\n  let user = FactoryGuy.make('user', {projects: projects});\r\n  user.get('projects.length') // => 2\r\n\r\n```\r\n\r\n*Note that though you are setting the 'projects' hasMany association on a user,\r\nthe reverse 'user' belongsTo association is being setup for you on the project\r\n( for both manual and factory defined hasMany associations ) as well*\r\n\r\n```javascript\r\n  projects.get('firstObject.user')  // => user\r\n```\r\n\r\n\r\n\r\n### Extending Other Definitions\r\n  - Extending another definition will inherit these sections:\r\n    - sequences\r\n    - traits\r\n    - default attributes\r\n  - Inheritance is fine grained, so in each section, any attribute that is local\r\n    will take precedence over an inherited one. So you can override some\r\n    attributes in the default section ( for example ), and inherit the rest\r\n\r\n  - [Sample Factory using inheritance (big-group.js):](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/dummy/app/tests/factories/big-group.js)\r\n\r\n\r\n### Callbacks\r\n - afterMake\r\n  - Uses transient attributes\r\n\r\nAssuming the factory-guy model definition defines afterMake function:\r\n\r\n```javascript\r\n  FactoryGuy.define('property', {\r\n    default: {\r\n      name: 'Silly property'\r\n    },\r\n\r\n    // optionally set transient attributes, that will be passed in to afterMake function\r\n    transient: {\r\n      for_sale: true\r\n    },\r\n\r\n    // The attributes passed to after make will include any optional attributes you\r\n    // passed in to make, and the transient attributes defined in this definition\r\n    afterMake: function(model, attributes) {\r\n      if (attributes.for_sale) {\r\n        model.set('name', model.get('name') + '(FOR SALE)');\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\nYou would use this to make models like:\r\n\r\n```javascript\r\n  Ember.run(function () {\r\n\r\n    let property = FactoryGuy.make('property');\r\n    property.get('name'); // => 'Silly property(FOR SALE)')\r\n\r\n    let property = FactoryGuy.make('property', {for_sale: false});\r\n    property.get('name'); // => 'Silly property')\r\n  });\r\n\r\n```\r\n\r\n### Ember Data Model Fragments\r\nAs of 2.5.2 you can create factories which contain [ember-data-model-fragments](https://github.com/lytics/ember-data-model-fragments). Setting up your fragments is easy and follows the same process as setting up regular factories. The mapping between fragment types and their associations are like so:\r\n\r\nFragment Type | Association\r\n--- | ---\r\n`fragment` | `FactoryGuy.belongsTo`\r\n`fragmentArray` | `FactoryGuy.hasMany`\r\n`array` | `[]`\r\n\r\nFor example, say we have the following `Employee` model which makes use of the `fragment`, `fragmentArray` and `array` fragment types.\r\n\r\n```javascript\r\n//Employee model\r\nexport default Model.extend({\r\n  name      : fragment('name'),\r\n  phoneNumbers: fragmentArray('phone-number')\r\n})\r\n\r\n//Name fragment\r\nexport default Fragment.extend({\r\n  titles: array('string'),\r\n  firstName : attr('string'),\r\n  lastName  : attr('string')\r\n});\r\n\r\n//Phone Number fragment\r\nexport default Fragment.extend({\r\n  number: attr('string')\r\n  type: attr('string')\r\n});\r\n```\r\n\r\nA factory for this model and its fragments would look like so:\r\n\r\n```javascript\r\n// Employee factory\r\nFactoryGuy.define('employee', {\r\n  default: {\r\n    name: FactoryGuy.belongsTo('name'), //fragment\r\n    phoneNumbers: FactoryGuy.hasMany('phone-number') //fragmentArray\r\n  }\r\n});\r\n\r\n// Name fragment factory\r\nFactoryGuy.define('employee', {\r\n  default: {\r\n    titles: ['Mr.', 'Dr.'], //array\r\n    firstName: 'Jon',\r\n    lastName: 'Snow'\r\n  }\r\n});\r\n\r\n// Phone number fragment factory\r\nFactoryGuy.define('phone-number', {\r\n  default: {\r\n    number: '123-456-789',\r\n    type: 'home'\r\n  }\r\n});\r\n\r\n// TIP: You can set up associations manually ( and not necessarily in factory ) \r\n// To set up an employee ( hasMany ) phone numbers manually, try this:  \r\nlet phoneNumbers = buildList('phone-numbers', 2).get();\r\nlet employee = make('employee', { phoneNumbers });\r\n\r\n```\r\n\r\nFor a more detailed example of setting up fragments have a look at:\r\n  - model test [employee test](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/unit/models/employee-test.js).\r\n  - acceptance test [employee-view-test](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/acceptance/employee-view-test.js).\r\n\r\n### Creating Factories in Addons\r\nIf you are making an addon with factories and you want the factories available to Ember apps using your addon, place the factories in `test-support/factories` instead of `tests/factories`. They should be available both within your addon and in Ember apps using your addon.\r\n\r\n### Ember Django Adapter \r\n  - As of 2.6.1 you can use [ember-django-adapter](https://github.com/danielspaniel/ember-data-factory-guy#ember-django-adapter)  \r\n  - Everything is setup automatically\r\n  - Remember that sideloading is not supported in DRFSerializer so all relationships should either\r\n    - be set as embedded with DS.EmbeddedRecordsMixin if you want to use build/buildList \r\n    - or user make/makeList and in you mocks, and return models instead of json:\r\n```javascript\r\n  let projects = makeList('projects', 2); // put projects in the store\r\n  let user = make('user', { projects });  // attatch them to user\r\n  mockFind('user').returns({model: user}); // now the mock will return a user that has projects\r\n```\r\n  - using `fails()` with errors hash is not working reliably \r\n    - so you can always just `mockWhatever(args).fails()`  \r\n\r\n### Custom API formats\r\n\r\nFactoryGuy handles JSON-API / RESTSerializer / JSONSerializer out of the box.\r\n\r\nIn case your API doesn't follow either of these conventions, you can still make a custom fixture builder,\r\n or modify the FixtureConverters and JSONPayload classes that exist.\r\n - For now, before I launch into the details, let me know if you need this hookup and I \r\n   can guide you to a solution, since the use cases will be rare and varied.\r\n\r\n\r\n### Testing - Creating Scenarios\r\n- Easy to create complex scenarios involving multi layered relationships.\r\n  - Can use model instances to create relationships for making other models.\r\n  \r\nExample:\r\n\r\n  - Setup a scenario where a user has two projects and belongs to a company\r\n\r\n```javascript\r\n   let company = make('company');\r\n   let user = make('user', {company: company});\r\n   let projects = makeList('project', 2, {user: user});\r\n```\r\n\r\n*You can use traits to help create the relationships as well, but this strategy allows you to\r\nbuild up complex scenarios in a different way that has it's own benefits.*\r\n\r\n####cacheOnlyMode\r\n- FactoryGuy.cacheOnlyMode\r\n  - Allows you to setup the adapters to prevent them from fetching data with ajax call \r\n    - for single models ( find ) you have to put something in the store\r\n    - for collections ( findAll ) you don't have to put anything in the store.\r\n  - Takes `except` parameter as a list of models you don't want to cache. \r\n    - These model requests will go to server with ajax call and need to be mocked.\r\n   \r\nThis is helpful, when: \r\n  - you want to set up the test data with make/makeList, and then prevent\r\n    calls like store.find or findAll from fetching more data, since you have \r\n    already setup the store with make/makeList data. \r\n  - you have an application that starts up and loads data that is not relevant\r\n    to the test page you are working on. \r\n\r\nUsage:\r\n\r\n```javascript\r\nimport FactoryGuy, { makeList } from 'ember-data-factory-guy';\r\nimport moduleForAcceptance from '../helpers/module-for-acceptance';\r\n\r\nmoduleForAcceptance('Acceptance | Profiles View');\r\n\r\ntest(\"Using FactoryGuy.cacheOnlyMode\", function() {\r\n  FactoryGuy.cacheOnlyMode();\r\n  // the store.find call for the user will go out unless there is a user\r\n  // in the store\r\n  make('user', {name: 'current'});\r\n  // the application starts up and makes calls to findAll a few things, but\r\n  // those can be ignored because of the cacheOnlyMode\r\n  \r\n  // for this test I care about just testing profiles\r\n  makeList(\"profile\", 2);\r\n\r\n  visit('/profiles');\r\n\r\n  andThen(()=> {\r\n    // test stuff\r\n  });\r\n});\r\n\r\ntest(\"Using FactoryGuy.cacheOnlyMode with except\", function() {\r\n  FactoryGuy.cacheOnlyMode({except: ['profile']});\r\n\r\n  make('user', {name: 'current'});\r\n  \r\n  // this time I want to allow the ajax call so I can return built json payload\r\n  mockFindAll(\"profile\", 2);\r\n\r\n  visit('/profiles');\r\n\r\n  andThen(()=> {\r\n    // test stuff\r\n  });\r\n});\r\n```\r\n  \r\n### Testing models, controllers, components\r\n\r\n- FactoryGuy needs to setup the factories before the test run.\r\n  - use manualSetup function to set up FactoryGuy in unit/component tests\r\n\r\n- [Sample model test (profile-test.js):](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/unit/models/profile-test.js)\r\n  - Use 'moduleForModel' ( ember-qunit ), or describeModel ( ember-mocha ) test helper\r\n  - manually set up Factory guy \r\n  \r\n- [Sample component test #1 (single-user-manual-setup-test.js):](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/components/single-user-manual-setup-test.js)\r\n  - Using 'moduleForComponent' ( ember-qunit ), or describeComponent ( ember-mocha ) helper\r\n  - Manually sets up Factory guy ( so it's faster )\r\n\r\n  ```javascript\r\n  import { make, manualSetup }  from 'ember-data-factory-guy';\r\n  import hbs from 'htmlbars-inline-precompile';\r\n  import { test, moduleForComponent } from 'ember-qunit';\r\n  \r\n  moduleForComponent('single-user', 'Integration | Component | single-user (manual setup)', {\r\n    integration: true,\r\n  \r\n    beforeEach: function () {\r\n      manualSetup(this.container);\r\n    }\r\n  });\r\n          \r\n  test(\"shows user information\", function () {\r\n    let user = make('user', {name: 'Rob'});\r\n  \r\n    this.render(hbs`{{single-user user=user}}`);\r\n    this.set('user', user);\r\n  \r\n    ok(this.$('.name').text().match(user.get('name')));\r\n    ok(this.$('.funny-name').text().match(user.get('funnyName')));\r\n  });\r\n  ```\r\n\r\n- [Sample component test #2 (single-user-test.js):](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/components/single-user-test.js)\r\n  - Using 'moduleForComponent' ( ember-qunit ), or describeComponent ( ember-mocha ) helper\r\n  - Starts a new application with startApp() before each test  ( slower )\r\n\r\n\r\n### Acceptance Tests\r\n\r\n##### Using mock methods\r\n\r\n- Uses mockjax\r\n  - for mocking the ajax calls made by ember-data.\r\n  - this library is installed with ember-data-factory-guy.\r\n- http GET mocks\r\n  - [mockFind](https://github.com/danielspaniel/ember-data-factory-guy#mockfind)\r\n  - [mockFindAll](https://github.com/danielspaniel/ember-data-factory-guy#mockfindall)\r\n  - [mockReload](https://github.com/danielspaniel/ember-data-factory-guy#mockreload)\r\n  - [mockQuery](https://github.com/danielspaniel/ember-data-factory-guy#mockquery)\r\n  - [mockQueryRecord](https://github.com/danielspaniel/ember-data-factory-guy#mockqueryrecord)\r\n  - takes modifier method `returns()` for setting the payload response\r\n    - `returns()` accepts parameters like: json, model, models, id, ids, headers\r\n      - headers are cumulative so you can add as many as you like\r\n      - Example: \r\n      ```javascript\r\n        let mock = mockFindAll('user').returns({headers: {'X-Man': \"Wolverine\"}); \r\n        mock.returns({headers: {'X-Weapon': \"Claws\"}); \r\n      ```\r\n  - these mocks are are reusable\r\n    - so you can simulate making the same ajax call ( url ) and return a different payload\r\n- http POST/PUT/DELETE\r\n  - [mockCreate](https://github.com/danielspaniel/ember-data-factory-guy#mockcreate)\r\n  - [mockUpdate](https://github.com/danielspaniel/ember-data-factory-guy#mockupdate)\r\n  - [mockDelete](https://github.com/danielspaniel/ember-data-factory-guy#mockdelete)\r\n- can use method `fails()` to simulate failure, and then `succeeds()` to simulate success\r\n  - to customize failure, fails method takes optional object with status and errors.\r\n  - Example: \r\n  ```javascript\r\n    let mock = mockFindAll('user').fails({status: 401, errors: {description: \"Unauthorized\"}}); \r\n  ```\r\n- mock#timesCalled \r\n  - verify how many times the ajax call was mocked\r\n  - use `timesCalled` property on the mock\r\n  - works when you are using mockQuery, mockQueryRecord, mockFindAll, or mockUpdate\r\n  - mockFind will always be at most 1 since it will only make ajax call\r\n    the first time, and then the store will use cache the second time\r\n  - Example:\r\n  ```javascript\r\n    const mock = mockQueryRecord('company', {}).returns({ json: build('company') });\r\n  \r\n    FactoryGuy.store.queryRecord('company', {}).then(()=> {\r\n      FactoryGuy.store.queryRecord('company', {}).then(()=> {\r\n        mock.timesCalled //=> 2\r\n      });\r\n    });\r\n  ```\r\n\r\n##### setup and teardown\r\n  - Use ```mockSetup()``` in test setup/beforeEach \r\n  - Use ```mockTeardown()``` in test teardown/afterEach\r\n  - Easiest is to set them up in [module-for-acceptance.js:](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/helpers/module-for-acceptance.js)\r\n\r\n##### mockFind\r\n  - For dealing with finding one record of a model type => `store.find('modelType')`\r\n  - Can pass in arguments just like you would for [make](https://github.com/danielspaniel/ember-data-factory-guy#make) or [build](https://github.com/danielspaniel/ember-data-factory-guy#build)\r\n    - mockFind( fixture or model name, optional traits, optional attributes object)\r\n  - Takes modifier method `returns()` for controlling the response payload\r\n    - returns( model / json / id )\r\n  - Sample acceptance tests using mockFind: [user-view-test.js:](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/acceptance/user-view-test.js)\r\n\r\nUsage:\r\n```javascript\r\n   import { build, make, mockFind } from 'ember-data-factory-guy';\r\n```\r\n- To return default factory model type ( 'user' in this case )\r\n```javascript\r\n   // mockFind automatically returns json for the modelType ( in this case 'user' )  \r\n   let mock = mockFind('user');\r\n   let userId = mock.get('id');\r\n```\r\n- Using `returns({json})` to return json object  \r\n```javascript\r\n   let user = build('user', 'whacky', {isDude: true});\r\n   let mock = mockFind('user').returns({ json: user });\r\n   // user.get('id') => 1\r\n   // user.get('style') => 'whacky'\r\n   \r\n   // or to acccomplish the same thing with less code \r\n   let mock = mockFind('user', 'whacky', {isDude: true});\r\n   // mock.get('id') => 1\r\n   // mock.get('style') => 'whacky'\r\n   let user = mock.get();\r\n   // user.id => 1\r\n   // user.style => 'whacky'\r\n```\r\n- Using `returns({model})` to return model instance\r\n```javascript\r\n   let user = make('user', 'whacky', {isDude: false});\r\n   let mock = mockFind('user').returns({ model: user });\r\n   // user.get('id') => 1\r\n   // you can now also user.get('any-computed-property') \r\n   // since you have a real model instance\r\n```\r\n- To reuse the mock\r\n```javascript\r\n   let user2 = build('user', {style: \"boring\"});\r\n   mock.returns({ json: user2 });\r\n   // mock.get('id') => 2\r\n```\r\n- To mock failure case use `fails` method\r\n```javascript  \r\n   mockFind('user').fails();\r\n```\r\n\r\n##### mockFindAll\r\n  - For dealing with finding all records for a model type => `store.findAll(modelType)`\r\n  - Takes same parameters as [makeList](https://github.com/danielspaniel/ember-data-factory-guy#makelist)\r\n    - mockFindAll( fixture or model name, optional number, optional traits, optional attributes object)\r\n  - Takes modifier method `returns()` for controlling the response payload\r\n    - returns( models / json / ids )\r\n  - Sample acceptance tests using mockFindAll: [users-view-test.js](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/acceptance/users-view-test.js) \r\n\r\nUsage:\r\n\r\n```javascript\r\n   import { buildList, makeList, mockFindAll } from 'ember-data-factory-guy';\r\n```\r\n- To mock and return no results\r\n```javascript\r\n   let mock = mockFindAll('user');\r\n```\r\n- Using `returns({json})` to return json object  \r\n```javascript\r\n   // that has 2 different users:\r\n   let users = buildList('user', 'whacky', 'silly');\r\n   let mock = mockFindAll('user').returns({ json: users });\r\n   let user1 = users.get(0);\r\n   let user2 = users.get(1);\r\n   // user1.style => 'whacky'\r\n   // user2.style => 'silly'\r\n   \r\n   // or to acccomplish the same thing with less code \r\n   let mock = mockFindAll('user', 'whacky', 'silly');\r\n   let user1 = mock.get(0);\r\n   let user2 = mock.get(1);\r\n   // user1.style => 'whacky'\r\n   // user2.style => 'silly'\r\n```\r\n - Using `returns({models})` to return model instances\r\n```javascript\r\n    let users = makeList('user', 'whacky', 'silly');\r\n    let mock = mockFindAll('user').returns({ models: users });\r\n    let user1 = users[0];\r\n    // you can now also user1.get('any-computed-property') \r\n    // since you have a real model instance\r\n```\r\n- To reuse the mock and return different payload\r\n```javascript   \r\n   let users2 = buildList('user', 3);\r\n   mock.returns({ json: user2 });\r\n```\r\n- To mock failure case use `fails()` method \r\n```javascript   \r\n   mockFindAll('user').fails();\r\n```\r\n\r\n##### mockReload\r\n  - To handle reloading a model\r\n    - Pass in a record ( or a typeName and id )\r\n\r\nUsage:\r\n\r\n- Passing in a record / model instance\r\n\r\n```javascript\r\n    let profile = make('profile');\r\n    mockReload(profile);\r\n\r\n    // will stub a call to reload that profile\r\n    profile.reload()\r\n```\r\n\r\n- Mocking a failed reload\r\n      \r\n```javascript \r\n    mockReload('profile', 1).fails();\r\n```\r\n\r\n##### mockQuery\r\n  - For dealing with querying for all records for a model type => `store.query(modelType, params)`\r\n    - Takes modifier method `returns()` for controlling the response payload\r\n    - returns( models / json / ids )\r\n   - Takes modifier methods for matching the query params\r\n    - withParams( object )\r\n  - Sample acceptance tests using mockQuery: [user-search-test.js](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/acceptance/user-search-test.js)\r\n\r\nUsage: \r\n\r\n```js\r\n  import FactoryGuy, { make, build, buildList, mockQuery } from 'ember-data-factory-guy';\r\n  let store = FactoryGuy.store;\r\n\r\n  // This simulates a query that returns no results\r\n  mockQuery('user', {age: 10});\r\n\r\n  store.query('user', {age: 10}}).then((userInstances) => {\r\n    /// userInstances will be empty\r\n  })\r\n```\r\n\r\n  - with returns( models )\r\n```js\r\n  // Create model instances\r\n  let users = makeList('user', 2, 'with_hats');\r\n  \r\n  mockQuery('user', {name:'Bob', age: 10}).returns({models: users});\r\n  \r\n  store.query('user', {name:'Bob', age: 10}}).then((models)=> {\r\n    // models are the same as the users array\r\n  });\r\n```\r\n\r\n  - with returns ( json )\r\n``` js\r\n  // Create json with buildList\r\n  let users = buildList('user', 2, 'with_hats');\r\n  \r\n  mockQuery('user', {name:'Bob', age: 10}).returns({json: users});\r\n  \r\n  store.query('user', {name:'Bob', age: 10}}).then((models)=> {\r\n    // these models were created from the users json\r\n  });\r\n```\r\n\r\n  - with returns( ids )\r\n\r\n```js\r\n  // Create list of models\r\n  let users = buildList('user', 2, 'with_hats');\r\n  let user1 = users.get(0);\r\n  \r\n  mockQuery('user', {name:'Bob', age: 10}).returns({ids: [user1.id]});\r\n  \r\n  store.query('user', {name:'Bob', age: 10}}).then(function(models) {\r\n    // models will be one model and it will be user1\r\n  });\r\n\r\n```\r\n\r\n##### mockQueryRecord\r\n  - For dealing with querying for one record for a model type => `store.queryRecord(modelType, params)`\r\n    - Takes modifier method `returns()` for controlling the response payload\r\n    - returns( model / json / id )\r\n   - Takes modifier methods for matching the query params\r\n    - withParams( object )\r\n\r\n\r\nUsage: \r\n\r\n```js\r\n  import FactoryGuy, { make, build, mockQueryRecord } from 'ember-data-factory-guy';\r\n  let store = FactoryGuy.store;\r\n\r\n  // This simulates a query that returns no results\r\n  mockQueryRecord('user', {age: 10});\r\n\r\n  store.queryRecord('user', {age: 10}}).then((userInstance) => {\r\n    /// userInstance will be empty\r\n  })\r\n```\r\n\r\n  - with returns( models )\r\n```js\r\n  // Create model instances\r\n  let user = make('user');\r\n  \r\n  mockQueryRecord('user', {name:'Bob', age: 10}).returns({model: user});\r\n  \r\n  store.queryRecord('user', {name:'Bob', age: 10}}).then((model)=> {\r\n    // model is the same as the user you made\r\n  });\r\n```\r\n\r\n  - with returns ( json )\r\n``` js\r\n  // Create json with buildList\r\n  let user = build('user');\r\n  \r\n  mockQueryRecord('user', {name:'Bob', age: 10}).returns({json: user});\r\n  \r\n  store.queryRecord('user', {name:'Bob', age: 10}}).then((model)=> {\r\n    // user model created from the user json\r\n  });\r\n```\r\n\r\n  - with returns( ids )\r\n\r\n```js\r\n  // Create list of models\r\n  let user = build('user', 'with_hats');\r\n  \r\n  mockQueryRecord('user', {name:'Bob', age: 10}).returns({id: user.get('id')});\r\n  \r\n  store.queryRecord('user', {name:'Bob', age: 10}}).then(function(model) {\r\n    // model will be one model and it will be user1\r\n  });\r\n\r\n```\r\n\r\n##### mockCreate\r\n\r\n  - Use chainable methods to build the response\r\n    - match\r\n      - Attributes that must be in request json\r\n        - These will be added to the response json automatically, so\r\n          you don't need to include them in the returns hash.\r\n        - If you match on a belongsTo association, you don't have to include that in \r\n        the returns hash either ( same idea ).\r\n    - returns\r\n      - Attributes ( including relationships ) to include in response json\r\n    - fails\r\n      - Request will fail\r\n      - Takes a hash of options:\r\n        - status - HTTP status code, defaults to 500.\r\n        - response - error response message, or an errors hash for 422 status\r\n    - succeeds\r\n      - to retry a mock after a failed response\r\n      \r\n  - Need to wrap tests using mockCreate with: Ember.run.function() { 'your test' })\r\n\r\n\r\nRealistically, you will have code in a view action or controller action that will\r\n create the record, and setup any associations.\r\n\r\n```javascript\r\n\r\n  // most actions that create a record look something like this:\r\n  action: {\r\n    addProject: function (user) {\r\n      let name = this.$('button.project-name').val();\r\n      let store = this.get('controller.store');\r\n      store.createRecord('project', {name: name, user: user}).save();\r\n    }\r\n  }\r\n\r\n```\r\n\r\nIn this case, you are are creating a 'project' record with a specific name, and belonging\r\nto a particular user. To mock this createRecord call here are a few ways to do this using\r\nchainable methods.\r\n\r\n\r\nUsage:\r\n\r\n```javascript\r\n  import { mockCreate } from 'ember-data-factory-guy';\r\n  \r\n  // Simplest case\r\n  // Don't care about a match just handle createRecord for any project\r\n  mockCreate('project');\r\n\r\n  // Matching some attributes\r\n  mockCreate('project').match({name: \"Moo\"});\r\n\r\n  // Match all attributes\r\n  mockCreate('project').match({name: \"Moo\", user: user});\r\n\r\n  // Exactly matching attributes, and returning extra attributes\r\n  mockCreate('project')\r\n    .match({name: \"Moo\", user: user})\r\n    .returns({created_at: new Date()});\r\n\r\n  // Returning belongsTo relationship. Assume outfit belongsTo 'person'\r\n  let person = build('super-hero'); // it's polymorphic\r\n  mockCreate('outfit').returns({ person });\r\n\r\n  // Returning hasMany relationship. Assume super-hero hasMany 'outfits'\r\n  let outfits = buildList('outfit', 2);\r\n  mockCreate('super-hero').returns({ outfits });\r\n\r\n```\r\n\r\n  - mocking a failed create\r\n\r\n```javascript\r\n\r\n  // Mocking failure case is easy with chainable methods, just use #fails\r\n  mockCreate('project').match({name: \"Moo\"}).fails();\r\n\r\n  // Can optionally add a status code and/or errors to the response\r\n  mockCreate('project').fails({status: 422, response: {errors: {name: ['Moo bad, Bahh better']}}});\r\n\r\n  store.createRecord('project', {name: \"Moo\"}).save(); //=> fails\r\n```\r\n\r\n\r\n##### mockUpdate\r\n\r\n  - mockUpdate(model)\r\n    - Single argument ( the model instance that will be updated )\r\n  - mockUpdate(modelType, id)\r\n    - Two arguments: modelType ( like 'profile' ) , and the profile id that will updated\r\n  - Use chainable methods to help build response:\r\n    - returns\r\n      - Attributes ( including relationships ) to include in response json\r\n    - fails\r\n      - Request will fail\r\n      - Optional arguments ( status and response text )\r\n    - succeeds\r\n      - use this after an ```fails``` call to have update succeed\r\n  - Need to wrap tests using mockUpdate with: Ember.run.function() { 'your test' })\r\n\r\nUsage:\r\n\r\n```javascript\r\n  import { make, mockUpdate } from 'ember-data-factory-guy';\r\n  \r\n  let profile = make('profile');\r\n\r\n  // Pass in the model that will be updated ( if you have it available )\r\n  mockUpdate(profile);\r\n\r\n  // If the model is not available, pass in the modelType and the id of\r\n  // the model that will be updated\r\n  mockUpdate('profile', 1);\r\n\r\n  profile.set('description', 'good value');\r\n  profile.save() //=> will succeed\r\n  \r\n  // Returning belongsTo relationship. Assume outfit belongsTo 'person'\r\n  let outfit = make('outfit');\r\n  let person = build('super-hero'); // it's polymorphic\r\n  outfit.set('name','outrageous');\r\n  mockUpdate(outfit).returns({ person });\r\n  outfit.save(); //=> saves and returns superhero \r\n\r\n  // Returning hasMany relationship. Assume super-hero hasMany 'outfits'\r\n  let superHero = make('super-hero');\r\n  let outfits = buildList('outfit', 2, {name:'bell bottoms'});\r\n  superHero.set('style','laid back');\r\n  mockUpdate(superHero).returns({ outfits });\r\n  superHero.save(); // => saves and returns outfits\r\n  \r\n````\r\n\r\n - mocking a failed update\r\n\r\n```javascript\r\n  let profile = make('profile');\r\n\r\n  // set the succeed flag to 'false'\r\n  mockUpdate('profile', profile.id).fails({status: 422, response: 'Invalid data'});\r\n  // or\r\n  mockUpdate(profile).fails({status: 422, response: 'Invalid data'});\r\n\r\n  profile.set('description', 'bad value');\r\n  profile.save() //=> will fail\r\n````\r\n\r\n*mocking a failed update and retry with succees*\r\n\r\n```javascript\r\n  let profile = make('profile');\r\n\r\n  let mockUpdate = mockUpdate(profile);\r\n\r\n  mockUpdate.fails({status: 422, response: 'Invalid data'});\r\n\r\n  profile.set('description', 'bad value');\r\n  profile.save() //=> will fail\r\n\r\n  // After setting valid value\r\n  profile.set('description', 'good value');\r\n\r\n  // Now expecting success\r\n  mockUpdate.succeeds();\r\n\r\n  // Try that update again\r\n  profile.save() //=> will succeed!\r\n````\r\n\r\n\r\n\r\n##### mockDelete\r\n  - Need to wrap tests using mockDelete with: Ember.run.function() { 'your test' })\r\n  - To handle deleteing a model\r\n    - Pass in a record ( or a typeName and id )\r\n\r\nUsage:\r\n\r\n- Passing in a record / model instance\r\n\r\n```javascript\r\n  import { make, mockDelete } from 'ember-data-factory-guy';\r\n\r\n  let profile = make('profile');\r\n  mockDelete(profile);\r\n\r\n  profile.destroyRecord() // => will succeed\r\n```\r\n\r\n- Passing in a model typeName and id\r\n\r\n```javascript\r\n  import { make, mockDelete } from 'ember-data-factory-guy';\r\n\r\n  let profile = make('profile');\r\n  mockDelete('profile', profile.id);\r\n\r\n  profile.destroyRecord() // => will succeed\r\n```\r\n\r\n- Passing in a model typeName\r\n\r\n```javascript\r\n  import { make, mockDelete } from 'ember-data-factory-guy';\r\n\r\n  let profile1 = make('profile');\r\n  let profile2 = make('profile');\r\n  mockDelete('profile');\r\n\r\n  profile1.destroyRecord() // => will succeed\r\n  profile2.destroyRecord() // => will succeed\r\n```\r\n\r\n- Mocking a failed delete\r\n\r\n```javascript\r\n    mockDelete(profile).fails();\r\n```\r\n\r\n\r\n##### Sample Acceptance test [(user-view-test.js):](https://github.com/danielspaniel/ember-data-factory-guy/blob/master/tests/acceptance/user-view-test.js)\r\n\r\n\r\n```javascript\r\n// file: tests/acceptance/user-view-test.js\r\n\r\nimport { make, mockCreate, mockSetup, mockTeardown } from 'ember-data-factory-guy';\r\nimport moduleForAcceptance from '../helpers/module-for-acceptance';\r\n\r\nmoduleForAcceptance('Acceptance | User View', {\r\n  beforeEach: function () {\r\n    // mockSetup sets $.mockjaxSettings response time to zero ( speeds up tests )\r\n    mockSetup();\r\n  },\r\n  afterEach: function () {\r\n      // mockTeardown calls $.mockjax.clear() which resets all the mockjax handlers\r\n    mockTeardown();\r\n  }\r\n});\r\n\r\ntest(\"Creates new project\", function () {\r\n  let user = make('user', 'with_projects'); // build user payload\r\n  visit('/user/'+ user.get('id'));\r\n\r\n  andThen(function () {\r\n    let newProjectName = \"Gonzo Project\";\r\n\r\n    fillIn('input.project-name', newProjectName);\r\n\r\n    // Remember, this is for handling an exact match, if you did not care about\r\n    // matching attributes, you could just do: mockCreate('project')\r\n    mockCreate('project', {match: {name: newProjectName, user: user}});\r\n\r\n    /**\r\n     Let's say that clicking this 'button.add-project', triggers action in the view to\r\n     create project record and looks something like this:\r\n     actions: {\r\n        addProject: function (user) {\r\n          let name = this.$('input.project-name').val();\r\n          let store = this.get('controller.store');\r\n          store.createRecord('project', {name: name, user: user}).save();\r\n        }\r\n    */\r\n    click('button:contains(Add New User)');\r\n\r\n    andThen(function () {\r\n      let newProjectDiv = find('li.project:contains(' + newProjectName + ')');\r\n      ok(newProjectDiv[0] !== undefined);\r\n    });\r\n  });\r\n});\r\n\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}